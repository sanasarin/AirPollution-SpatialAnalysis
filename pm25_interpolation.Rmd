---
title: "PM2.5 interpolation"
---


```{r}
# libraries

library(tidyverse)
library(sf)
library(phylin)
library(dplyr)
library(automap)
library(sp)
library(gstat)

```

```{r}

# set working directory with setwd(dir)

air_data <- read_csv("data/air_data_states_pollutants.csv", show_col_types = FALSE, guess_max = 9500)
pm_data2 <- air_data%>%
  filter(`Parameter Name` == "PM2.5 - Local Conditions")

```


```{r}
# plot pm data
pm_data %>%
  as.data.frame() %>%
  ggplot(aes(Longitude, Latitude)) + 
  geom_point(color="blue", alpha=3/4) + 
  ggtitle("PM2.5 - Local Conditions Concentration") + 
  coord_equal() + 
  theme_bw()

```


```{r}

# convert to sf object and transform to EPSG 102004 (NAD 1983 Lambert contiguous USA)

crs = st_crs("EPSG:4326")
new_crs = st_crs("ESRI:102004")
pm_df_sf <- st_as_sf(pm_data, coords = c("Longitude", "Latitude"), crs = crs)%>%
  st_transform(new_crs)

states <- sf::st_read("data/states.shp") %>% st_transform(new_crs)
statesOutline <- fortify(states, region="Name")
```


```{r}

# plot points
ggplot() + 
  geom_sf(data=pm_df_sf) +
  geom_sf(data = statesOutline, color="black", fill=NA) +
  coord_sf(crs=new_crs)


```


```{r}
#make grid
grd_5000_sf <- states %>% 
  st_make_grid(
    cellsize = c(5000, 5000), # 5000m pixel size
    what = "corners"
  ) %>%
  st_as_sf()
grd_5000_sf  <- grd_5000_sf %>%
  cbind(. , st_coordinates(.))

```


```{r}

# get the points within the state boundaries
grd_sp <- as(grd_5000_sf, "Spatial")
states_sp <- as(states, "Spatial")

grid_in_poly <- sp::over(grd_sp, states_sp)
grid_predict <- grd_sp[complete.cases(grid_in_poly),]
plot(grid_predict)

```


```{r}

## get coordinates and value to interpolate from sf object
data <- pm_df_sf %>% 
  cbind(. , st_coordinates(.)) %>% 
  as.data.frame() %>% 
  dplyr::select(X,Y, `Arithmetic.Mean`)

```


```{r}

## get the coordinates of the grid
grd <- grid_predict %>% 
  as.data.frame() %>% 
  dplyr::select(X, Y)

```

IDW
```{r}
## perform the IDW and join back the coordinates of the grid
test_i <- phylin::idw(data[,3], 
                 data[,1:2],
                 grd) %>% 
  cbind(grd)

```


```{r}
# Cross validation (Leave one out)

# convert sf object to sp object
pm_spdf <- as(pm_df_sf, "Spatial")


```


```{r}

# This will give a plot of the RMSE values for each K value and the value 
# of K with the lowest RMSE will be indicated with a red line (run the code). 
# We can use the value of K with the lowest RMSE for our final model.

# Let's find the best k/p value
# create an empty data frame to store p values and RMSE values
r <- data.frame(p = integer(), RMSE = numeric())

test_val <- c(0.5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

# loop through different p values and perform cross-validation
for (p in test_val) {
  LOOCV <- krige.cv(formula=Arithmetic.Mean~1, locations=pm_spdf, nfold=nrow(pm_spdf), set = list(idp = p))
  
  # calculate RMSE
  RMSE <- sqrt(mean(LOOCV@data$residual^2))
  # add p and RMSE values to the results data frame
  r <- rbind(r, data.frame(p = p, RMSE = RMSE))
}

# find the p value with the lowest RMSE
best_idw <- r[which.min(r$RMSE),]
cat("The best p value is", best_idw$p, "with an RMSE of", best_idw$RMSE)

# result is 2, so we keep the previous result

```


```{r}

ggplot(r, aes(x = p, y = RMSE)) + 
  geom_line() + 
  geom_point() +
  scale_x_continuous(breaks = seq(1, 20, by = 1)) + 
  labs(x = "p value", y = "RMSE")

```


```{r}

# rename Z to Mean
test_i <- test_i %>% mutate(Mean = Z) %>% dplyr::select(-Z)

#get summary
summary(test_i)

```


```{r}

# tiled (filled) interpolation, displayed in EPSG 102004 coordinate system
ggplot() + 
  geom_tile(data=test_i, aes(x=X, y=Y, fill=Mean)) +
  geom_sf(data = statesOutline, color="black", fill=NA) +
  coord_sf(crs=new_crs) +
  labs(title="IDW Interpolated PM2.5 Values", fill="Mean (Micrograms/cubic meter)") +
  xlab("Longitude")+
  ylab("Latitude")


```

Kriging

```{r}
# assumption 1: data is normal
hist(pm_data$`Arithmetic Mean`)
shapiro.test(pm_data$`Arithmetic Mean`)

# It looks normal and the p value > 0.05
```

```{r}
# assumption 2: mean and variance are equal

# Find extent values
# Using functions in the raster package
library(raster)
area <- extent(pm_spdf@bbox)
area


```

```{r}
# Create a raster of 5 x 5 covering the area
pm_raster <- raster(nrows = 4, ncols = 4, ext = area,
                      vals = -999)
# Convert Raster to Polygons
polygons_area <- rasterToPolygons(pm_raster)
crs(polygons_area) <- crs(pm_spdf)

# Removing all columns except arithmetic mean
pm_spdf_mean <- pm_spdf[,26]
# Number of obserations per polygon
assessment <- over(polygons_area, pm_spdf_mean)
# Mean of values
assessment$mean <- over(polygons_area, pm_spdf_mean,
                        fn = mean, na.rm = T)[,1]
# Variance of Values
assessment$var <- over(polygons_area, pm_spdf_mean,
                       fn = var, na.rm = T)[,1]
# Change Names
names(assessment)[1] <- c("counts")
# Replace Polygon Data
polygons_area@data <- assessment
summary(polygons_area@data)
spplot(polygons_area, c("counts", "mean", "var"), names.attr = c("Count","Mean", "Variance"),
       colorkey=list(space="bottom"), scales = list(draw = TRUE),
       main = "Stationarity Test",
       as.table = TRUE)

summary(polygons_area)


```

```{r}

# assumption 3: isotrophy
# Look at IDW plot again to see if there's any spatial trend
ggplot() + 
  geom_tile(data=test_i, aes(x=X, y=Y, fill=Mean)) +
  geom_sf(data = statesOutline, color="white", fill=NA) +
  coord_sf(crs=new_crs)

```

```{r}
pm_vgm <- variogram(Arithmetic.Mean~1, data = pm_spdf)

# see all types of variograms 
show.vgms()

pm_fit <- fit.variogram(pm_vgm, model = vgm(model="Sph"))
plot(pm_vgm, pm_fit) # plot the sample values, along with the fit model

pm_fit

# psill: 1.62467
# range: 17941.71	
```

```{r}

# Performing kriging
# for the points grid, we already made that in the previous step for IDW
# Let's look at it:
plot(grd_sp)
plot(states_sp)

```


